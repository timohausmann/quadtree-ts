/* https://github.com/timohausmann/quadtree-ts.git v2.3.0 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Quadtree=e()}(this,function(){"use strict";class t{constructor(t){this.x=t.x,this.y=t.y,this.r=t.r,this.data=t.data}qtIndex(e){const s=[],i=e.width/2,h=e.height/2,n=e.x+i,o=e.y+h,r=[[n,e.y],[e.x,e.y],[e.x,o],[n,o]];for(let e=0;e<r.length;e++)t.intersectRect(this.x,this.y,this.r,r[e][0],r[e][1],r[e][0]+i,r[e][1]+h)&&s.push(e);return s}static intersectRect(t,e,s,i,h,n,o){const r=t-Math.max(i,Math.min(t,n)),l=e-Math.max(h,Math.min(e,o));return r*r+l*l<s*s}}class e{constructor(t){this.x1=t.x1,this.y1=t.y1,this.x2=t.x2,this.y2=t.y2,this.data=t.data}qtIndex(t){const s=[],i=t.width/2,h=t.height/2,n=t.x+i,o=t.y+h,r=[[n,t.y],[t.x,t.y],[t.x,o],[n,o]];for(let t=0;t<r.length;t++)e.intersectRect(this.x1,this.y1,this.x2,this.y2,r[t][0],r[t][1],r[t][0]+i,r[t][1]+h)&&s.push(t);return s}static intersectRect(t,e,s,i,h,n,o,r){if(t<=h&&s<=h||e<=n&&i<=n||t>=o&&s>=o||e>=r&&i>=r)return!1;if(t>=h&&t<=o&&e>=n&&e<=r||s>=h&&s<=o&&i>=n&&i<=r)return!0;const l=(i-e)/(s-t);let c=l*(h-t)+e;if(c>n&&c<r)return!0;if(c=l*(o-t)+e,c>n&&c<r)return!0;let d=(n-e)/l+t;return d>h&&d<o||(d=(r-e)/l+t,d>h&&d<o)}}return Object.assign(class{constructor(t,e=0){if(this.bounds={x:t.x||0,y:t.y||0,width:t.width,height:t.height},this.maxObjects="number"==typeof t.maxObjects?t.maxObjects:10,this.minLevels="number"==typeof t.minLevels?t.minLevels:0,this.maxLevels="number"==typeof t.maxLevels?t.maxLevels:4,this.level=e,this.minLevels>this.maxLevels)throw new Error(`minLevels (${this.minLevels}) must be less than maxLevels (${this.maxLevels})`);this.objects=[],this.nodes=[],this.level<this.minLevels&&this.split()}getIndex(t){return t.qtIndex(this.bounds)}split(){const t=this.level+1,e=this.bounds.width/2,s=this.bounds.height/2,i=this.bounds.x,h=this.bounds.y,n=[{x:i+e,y:h},{x:i,y:h},{x:i,y:h+s},{x:i+e,y:h+s}],o=this.constructor;for(let i=0;i<4;i++)this.nodes[i]=new o({x:n[i].x,y:n[i].y,width:e,height:s,maxObjects:this.maxObjects,minLevels:this.minLevels,maxLevels:this.maxLevels},t)}insert(t){if(this.nodes.length){const e=this.getIndex(t);for(let s=0;s<e.length;s++)this.nodes[e[s]].insert(t);return}if(this.objects.push(t),this.objects.length>this.maxObjects&&this.level<this.maxLevels){this.split();for(let t=0;t<this.objects.length;t++){const e=this.getIndex(this.objects[t]);for(let s=0;s<e.length;s++)this.nodes[e[s]].insert(this.objects[t])}this.objects=[]}}retrieve(t){const e=this.getIndex(t);let s=this.objects;if(this.nodes.length)for(let i=0;i<e.length;i++)s=s.concat(this.nodes[e[i]].retrieve(t));return 0===this.level?Array.from(new Set(s)):s}remove(t,e=!1){const s=this.objects.indexOf(t);s>-1&&this.objects.splice(s,1);for(let e=0;e<this.nodes.length;e++)this.nodes[e].remove(t);return 0!==this.level||e||this.join(),-1!==s}update(t,e=!1){this.remove(t,e),this.insert(t)}join(){let t=Array.from(this.objects);for(let e=0;e<this.nodes.length;e++){const s=this.nodes[e].join();t=t.concat(s)}const e=Array.from(new Set(t));if(e.length<=this.maxObjects&&this.level>=this.minLevels){this.objects=e;for(let t=0;t<this.nodes.length;t++)this.nodes[t].objects=[];this.nodes=[]}return t}clear(){this.objects=[];for(let t=0;t<this.nodes.length;t++)this.nodes.length&&this.nodes[t].clear();this.level>=this.minLevels&&(this.nodes=[])}},{Rectangle:class{constructor(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this.data=t.data}qtIndex(t){const e=[],s=t.x+t.width/2,i=t.y+t.height/2,h=this.y<i,n=this.x<s,o=this.x+this.width>s,r=this.y+this.height>i;return h&&o&&e.push(0),n&&h&&e.push(1),n&&r&&e.push(2),o&&r&&e.push(3),e}},Circle:t,Line:e})});
