/* https://github.com/timohausmann/quadtree-ts.git v2.0.0-beta.2 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Quadtree=e()}(this,(function(){"use strict";class t{constructor(t,e=0){this.bounds={x:t.x||0,y:t.y||0,width:t.width,height:t.height},this.maxObjects="number"==typeof t.maxObjects?t.maxObjects:10,this.maxLevels="number"==typeof t.maxLevels?t.maxLevels:4,this.level=e,this.objects=[],this.nodes=[],this.objectIdMap=new WeakMap}getIndex(t){return t.qtIndex(this.bounds)}split(){const e=this.level+1,s=this.bounds.width/2,h=this.bounds.height/2,i=this.bounds.x,n=this.bounds.y,o=[{x:i+s,y:n},{x:i,y:n},{x:i,y:n+h},{x:i+s,y:n+h}];for(let i=0;i<4;i++)this.nodes[i]=new t({x:o[i].x,y:o[i].y,width:s,height:h,maxObjects:this.maxObjects,maxLevels:this.maxLevels},e)}insert(t){if(this.objectIdMap.set(t,Symbol()),this.nodes.length){const e=this.getIndex(t);for(let s=0;s<e.length;s++)this.nodes[e[s]].insert(t)}else if(this.objects.push(t),this.objects.length>this.maxObjects&&this.level<this.maxLevels){this.nodes.length||this.split();for(let t=0;t<this.objects.length;t++){const e=this.getIndex(this.objects[t]);for(let s=0;s<e.length;s++)this.nodes[e[s]].insert(this.objects[t])}this.objects=[]}}retrieve(t){const e=this.getIndex(t);let s=this.objects;if(this.nodes.length)for(let h=0;h<e.length;h++)s=s.concat(this.nodes[e[h]].retrieve(t));if(0===this.level){const t=new Map,e=s;s=[],e.forEach((e=>{const h=this.objectIdMap.get(e);t.has(h)||(s.push(e),t.set(h,!0))}))}return s}clear(){this.objects=[];for(let t=0;t<this.nodes.length;t++)this.nodes.length&&this.nodes[t].clear();this.nodes=[]}}class e{constructor(t){this.x=t.x,this.y=t.y,this.r=t.r,this.data=t.data}qtIndex(t){const s=[],h=t.width/2,i=t.height/2,n=t.x+h,o=t.y+i,c=[[n,t.y],[t.x,t.y],[t.x,o],[n,o]];for(let t=0;t<c.length;t++)e.intersectRect(this.x,this.y,this.r,c[t][0],c[t][1],c[t][0]+h,c[t][1]+i)&&s.push(t);return s}static intersectRect(t,e,s,h,i,n,o){const c=t-Math.max(h,Math.min(t,n)),r=e-Math.max(i,Math.min(e,o));return c*c+r*r<s*s}}class s{constructor(t){this.x1=t.x1,this.y1=t.y1,this.x2=t.x2,this.y2=t.y2,this.data=t.data}qtIndex(t){const e=[],h=t.width/2,i=t.height/2,n=t.x+h,o=t.y+i,c=[[n,t.y],[t.x,t.y],[t.x,o],[n,o]];for(let t=0;t<c.length;t++)s.intersectRect(this.x1,this.y1,this.x2,this.y2,c[t][0],c[t][1],c[t][0]+h,c[t][1]+i)&&e.push(t);return e}static intersectRect(t,e,s,h,i,n,o,c){if(t<=i&&s<=i||e<=n&&h<=n||t>=o&&s>=o||e>=c&&h>=c)return!1;if(t>=i&&t<=o&&e>=n&&e<=c||s>=i&&s<=o&&h>=n&&h<=c)return!0;const r=(h-e)/(s-t);let d=r*(i-t)+e;if(d>n&&d<c)return!0;if(d=r*(o-t)+e,d>n&&d<c)return!0;let l=(n-e)/r+t;return l>i&&l<o||(l=(c-e)/r+t,l>i&&l<o)}}return Object.assign(t,{Rectangle:class{constructor(t){this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this.data=t.data}qtIndex(t){const e=[],s=t.x+t.width/2,h=t.y+t.height/2,i=this.y<h,n=this.x<s,o=this.x+this.width>s,c=this.y+this.height>h;return i&&o&&e.push(0),n&&i&&e.push(1),n&&c&&e.push(2),o&&c&&e.push(3),e}},Circle:e,Line:s})}));
